window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "polar_diagrams", "modulename": "polar_diagrams", "kind": "module", "doc": "<h1 id=\"polar-diagrams-for-model-comparison\">Polar Diagrams for Model Comparison</h1>\n\n<h2 id=\"manuscript\">Manuscript</h2>\n\n<p>This library is created for the following paper:</p>\n\n<p><strong><em>\"Name of the paper\"</em></strong> by Aleksandar An\u017eel, Dominik Heider, and Georges Hattab</p>\n\n<p>Please cite the paper as:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>Bibtex citation placeholder\n</code></pre>\n</div>\n\n<hr />\n\n<p>Abstract:</p>\n\n<blockquote>\n  <p>Abstract placeholder</p>\n</blockquote>\n\n<h2 id=\"dependencies\">Dependencies</h2>\n\n<p>The code is written in Python 3.9.15 and tested on Linux with the following libraries installed:</p>\n\n<table>\n<thead>\n<tr>\n  <th>Library</th>\n  <th>Version</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>numpy</td>\n  <td>1.23.5</td>\n</tr>\n<tr>\n  <td>pandas</td>\n  <td>1.5.2</td>\n</tr>\n<tr>\n  <td>scikit-learn</td>\n  <td>1.2.0</td>\n</tr>\n<tr>\n  <td>scipy</td>\n  <td>1.9.3</td>\n</tr>\n<tr>\n  <td>plotly</td>\n  <td>5.9.0</td>\n</tr>\n<tr>\n  <td>kaleido</td>\n  <td>0.2.1</td>\n</tr>\n</tbody>\n</table>\n\n<p>The dependencies can also be found in <a href=\"requirements.txt\">requirements.txt</a>.</p>\n\n<h2 id=\"data\">Data</h2>\n\n<table>\n<thead>\n<tr>\n  <th>Location</th>\n  <th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td><a href=\"./Data/\">Data/</a></td>\n  <td>contains all datasets used in <a href=\"./Source/main.ipynb\">Source/main.ipynb</a>.</td>\n</tr>\n<tr>\n  <td><a href=\"./Data/Dataset_0/\">Data/Dataset_0/</a></td>\n  <td>contains the Anscombe's quartet data set.</td>\n</tr>\n<tr>\n  <td><a href=\"./Data/Dataset_1/\">Data/Dataset_1/</a></td>\n  <td>contains the official, automatically generated script for downloading the CMIP3 data from the <a href=\"https://esgf-node.llnl.gov/projects/cmip3/\">https://esgf-node.llnl.gov/projects/cmip3/</a>. To generate the whole data set, the user should first place itself into this directory and then run the following command from the terminal <code>sh generate_dataset_1.sh</code>. [1]</td>\n</tr>\n<tr>\n  <td><a href=\"./Data/Dataset_2/\">Data/Dataset_2/</a></td>\n  <td>contains the data set from the subsection <em>3.2 Example 2 \u2014 Machine Learning Model Evaluation</em> of our paper.</td>\n</tr>\n</tbody>\n</table>\n\n<p><strong>[1]</strong> The script used for downloading the <a href=\"./Data/Dataset_1/\">Dataset_1/</a> was generated using the tutorial found here <a href=\"https://esgf.github.io/esgf-user-support/faq.html#how-to-preserve-the-directory-structure\">https://esgf.github.io/esgf-user-support/faq.html#how-to-preserve-the-directory-structure</a>.\nScript can be automatically generated and downloaded again from here <a href=\"https://esgf-data.dkrz.de/esg-search/wget?download_structure=model&amp;project=CMIP3&amp;experiment=historical&amp;ensemble=run1&amp;variable=ts\">https://esgf-data.dkrz.de/esg-search/wget?download_structure=model&amp;project=CMIP3&amp;experiment=historical&amp;ensemble=run1&amp;variable=ts</a>.</p>\n\n<h2 id=\"code\">Code</h2>\n\n<table>\n<thead>\n<tr>\n  <th>Source Code</th>\n  <th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td><a href=\"./Source/\">Source/</a></td>\n  <td>contains all scripts.</td>\n</tr>\n<tr>\n  <td><a href=\"./Source/main.ipynb\">Source/main.ipynb</a></td>\n  <td>contains the IPython (jupyter) notebook that demonstrates the library using multiple datasets.</td>\n</tr>\n<tr>\n  <td><a href=\"./Source/polar_diagrams/diagrams.py\">Source/polar_diagrams/diagrams.py</a></td>\n  <td>contains the source code that imports the data, modifies it, calculates statistical and information theory properties, and builds diagrams.</td>\n</tr>\n<tr>\n  <td><a href=\"./Source/test.py\">Source/test.py</a></td>\n  <td>contains the source code for all unit tests.</td>\n</tr>\n</tbody>\n</table>\n\n<h2 id=\"getting-started\">Getting started</h2>\n\n<h3 id=\"the-scalar-feature\">The Scalar Feature</h3>\n\n<p><img src=\"./Data/README_Images/3-2-ml-ecoli-both-with-scalar.png\" alt=\"Scalar feature\" /></p>\n\n<h3 id=\"interactive-aspects\">Interactive aspects</h3>\n\n<p><img src=\"./Data/README_Images/General_navigation.gif\" alt=\"Tooltip\" /></p>\n\n<h2 id=\"installation-running\">Installation &amp; Running</h2>\n\n<h3 id=\"stable\">Stable</h3>\n\n<h3 id=\"unstable\">Unstable</h3>\n\n<h2 id=\"license\">License</h2>\n\n<p>Licensed under the GNU General Public License, Version 3.0 (<a href=\"./LICENSE\">LICENSE</a> or <a href=\"https://www.gnu.org/licenses/gpl-3.0.en.html\">https://www.gnu.org/licenses/gpl-3.0.en.html</a>)</p>\n\n<h3 id=\"contribution\">Contribution</h3>\n\n<p>Any contribution intentionally submitted for inclusion in the work by you, shall be licensed under the GNU GPLv3.</p>\n"}, {"fullname": "polar_diagrams.polar_diagrams", "modulename": "polar_diagrams.polar_diagrams", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "polar_diagrams.polar_diagrams.df_calculate_td_properties", "modulename": "polar_diagrams.polar_diagrams", "qualname": "df_calculate_td_properties", "kind": "function", "doc": "<p>df_calculate_td_properties caclulates all necessary statistical information\nfor the Taylor diagram from the input data set.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df_input (pandas.DataFrame):</strong>  This dataframe has models in columns and\nmodel prediction in rows. It is used to calculate relevant\nstatistical information.</li>\n<li><strong>string_reference_model (str):</strong>  This string contains the name of the\nmodel present in the df_input argument (as a column) which can be\nconsidered as a reference point in the final diagram. This is often\nthe ground truth.</li>\n<li><strong>string_corr_method (str, optional):</strong>  This string contains the name of\nthe method to be used when calculating the correlation. Defaults to\n'pearson'.</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>ValueError:</strong>  The error is raised if the string_corr_method is not one of\nthe following 'pearson', 'kendall', 'spearman'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>pandas.DataFrame: This dataframe contains model names as indices and\n    statistical properties as columns.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_input</span>, </span><span class=\"param\"><span class=\"n\">string_reference_model</span>, </span><span class=\"param\"><span class=\"n\">string_corr_method</span><span class=\"o\">=</span><span class=\"s1\">&#39;pearson&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "polar_diagrams.polar_diagrams.df_calculate_mid_properties", "modulename": "polar_diagrams.polar_diagrams", "qualname": "df_calculate_mid_properties", "kind": "function", "doc": "<p>df_calculate_mid_properties caclulates all necessary information theory\nproperties for the Mutual Information diagram from the input data set.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df_input (pandas.DataFrame):</strong>  This dataframe has models in columns and\nmodel prediction in rows. It is used to calculate relevan\ninformation theory propertiesdict_mi_parameters['discrete_models']</li>\n<li><strong>string_reference_model (str):</strong>  This string contains the name of the\nmodel present in the df_input argument (as a column) which can be\nconsidered as a reference point in the final diagram. This is often\nthe ground truth.</li>\n<li><strong>dict_mi_parameters (dict, optional):</strong>  This dictionary contains\nconfiguration parameters for the calculation of entropy and mutual\ninformation. Defaults to\ndict(int_mi_n_neighbors=3, string_entropy_method='auto',\n     bool_discrete_reference_model=False, discrete_models='auto',\n     int_random_state=_INT_RANDOM_SEED).</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>ValueError:</strong>  The error is raised if int_mi_n_neighbors is less or equal\nthan zero.</li>\n<li><strong>ValueError:</strong>  The error is raised if string_entropy_method is not one of\nthe following 'vasicek', 'van es', 'ebrahimi', 'correa', 'auto'</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>pandas.DataFrame: This dataframe contains model names as indices and\n    information theory properties as columns.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df_input</span>,</span><span class=\"param\">\t<span class=\"n\">string_reference_model</span>,</span><span class=\"param\">\t<span class=\"n\">dict_mi_parameters</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;string_entropy_method&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;auto&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;int_mi_n_neighbors&#39;</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"s1\">&#39;discrete_models&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;auto&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;bool_discrete_reference_model&#39;</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"s1\">&#39;int_random_state&#39;</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">}</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "polar_diagrams.polar_diagrams.df_calculate_all_properties", "modulename": "polar_diagrams.polar_diagrams", "qualname": "df_calculate_all_properties", "kind": "function", "doc": "<p>df_calculate_all_properties caclulates all necessary statistical and\ninformation theory properties for the Taylor and Mutual Information diagram\nfrom the input data set.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>df_input (pandas.DataFrame):</strong>  This dataframe has models in columns and\nmodel prediction in rows. It is used to calculate relevant\nstatistical information and information theory properties.</li>\n<li><strong>string_reference_model (str):</strong>  This string contains the name of the\nmodel present in the df_input argument (as a column) which can be\nconsidered as a reference point in the final diagram. This is often\nthe ground truth.</li>\n<li><strong>dict_mi_parameters (dict, optional):</strong>  This dictionary contains\nconfiguration parameters for the calculation of entropy and mutual\ninformation. Defaults to\ndict(int_mi_n_neighbors=3, string_entropy_method='auto',\n     bool_discrete_reference_model=False, discrete_fetures='auto',\n     int_random_state=_INT_RANDOM_SEED).</li>\n<li><strong>string_corr_method (str, optional):</strong>  This string contains the name of\nthe method to be used when calculating the correlation. Defaults to\n'pearson'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>pandas.DataFrame: This dataframe contains model names as indices and\n    statistical and information theory properties as columns.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df_input</span>,</span><span class=\"param\">\t<span class=\"n\">string_reference_model</span>,</span><span class=\"param\">\t<span class=\"n\">dict_mi_parameters</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;string_entropy_method&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;auto&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;int_mi_n_neighbors&#39;</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"s1\">&#39;discrete_models&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;auto&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;bool_discrete_reference_model&#39;</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"s1\">&#39;int_random_state&#39;</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">}</span>,</span><span class=\"param\">\t<span class=\"n\">string_corr_method</span><span class=\"o\">=</span><span class=\"s1\">&#39;pearson&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "polar_diagrams.polar_diagrams.chart_create_taylor_diagram", "modulename": "polar_diagrams.polar_diagrams", "qualname": "chart_create_taylor_diagram", "kind": "function", "doc": "<p>chart_create_taylor_diagram creates the Taylor diagram according to the\nlist_df_input argument where models are placed in columns and rows contain\nmodel predictions.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>list_df_input (list):</strong>  This list contains one or two dataframes which\nhave models in columns and model prediction in rows. If parsed as a\npd.DataFrame() object, it is considered as a first and only element\nof the list. Each one of these dataframes is used to calculate\nrelevant statistical information and information theory properties.\nIf the list contains two elements, both dataframes need to have the\nsame set of columns. If the second dataframe contains only one row,\nthen this dataframe is considered to contain a property that is\nencoded as using size of the marker of the resulting diagrams. If the\nsecond dataframe contains multiple rows, it is then considered to be\na second version of the first dataframe in the list. This is then\nencoded using solid borders around circle marks in the resulting\ndiagrams.</li>\n<li><strong>string_reference_model (str):</strong>  This string contains the name of the\nmodel present in the df_input argument (as a column) which can be\nconsidered as a reference point in the final diagram. This is often\nthe ground truth.</li>\n<li><strong>string_corr_method (str, optional):</strong>  This string contains the name of\nthe method to be used when calculating the correlation. Defaults to\n'pearson'.</li>\n<li><strong>bool_normalized_measures (bool, optional):</strong>  This boolean parameter is\nused to determine if the passed chart should have normalized entropy\nand STD values or not. If it is False, then real entropy and STD\nvalues are used for the radial axis. If it is True, normalized values\nare used. Defaults to False.</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>ValueError:</strong>  The error is raised if the string_corr_method is not one of\nthe following 'pearson', 'kendall', 'spearman'.</li>\n<li><strong>TypeError:</strong>  The error is raised if bool_notmalized_measures is not one\nof bool type.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>plotly.graph_objects.Figure: This chart contains the resulting Taylor\n    diagram.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">list_df_input</span>,</span><span class=\"param\">\t<span class=\"n\">string_reference_model</span>,</span><span class=\"param\">\t<span class=\"n\">string_corr_method</span><span class=\"o\">=</span><span class=\"s1\">&#39;pearson&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">bool_normalized_measures</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "polar_diagrams.polar_diagrams.chart_create_mi_diagram", "modulename": "polar_diagrams.polar_diagrams", "qualname": "chart_create_mi_diagram", "kind": "function", "doc": "<p>chart_create_mi_diagram creates the Mutual Information diagram according\nto the list_df_input argument where models are placed in columns and rows\ncontain model predictions.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>list_df_input (list):</strong>  This list contains one or two dataframes which\nhave models in columns and model prediction in rows. If parsed as a\npd.DataFrame() object, it is considered as a first and only element\nof the list. Each one of these dataframes is used to calculate\nrelevant statistical information and information theory properties.\nIf the list contains two elements, both dataframes need to have the\nsame set of columns. If the second dataframe contains only one row,\nthen this dataframe is considered to contain a property that is\nencoded as using size of the marker of the resulting diagrams. If the\nsecond dataframe contains multiple rows, it is then considered to be\na second version of the first dataframe in the list. This is then\nencoded using solid borders around circle marks in the resulting\ndiagrams.</li>\n<li><strong>string_reference_model (str):</strong>  This string contains the name of the\nmodel present in the df_input argument (as a column) which can be\nconsidered as a reference point in the final diagram. This is often\nthe ground truth.</li>\n<li><strong>string_mid_type (str, optional):</strong>  This string contains the type of the\nMutual Information diagram. If it is 'scaled' then it will span both\nquadrants. If it is 'normalized', it will span only the first\nquadrant of the circle. Defaults to 'scaled'.</li>\n<li><strong>dict_mi_parameters (dict, optional):</strong>  This dictionary contains\nconfiguration parameters for the calculation of entropy and mutual\ninformation. Defaults to\ndict(int_mi_n_neighbors=3, string_entropy_method='auto',\n     bool_discrete_reference_model=False, discrete_fetures='auto',\n     int_random_state=_INT_RANDOM_SEED).</li>\n<li><strong>bool_normalized_measures (bool, optional):</strong>  This boolean parameter is\nused to determine if the passed chart should have normalized entropy\nand STD values or not. If it is False, then real entropy and STD\nvalues are used for the radial axis. If it is True, normalized values\nare used. Defaults to False.</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>TypeError:</strong>  The error is raised if bool_notmalized_measures is not one\nof bool type.</li>\n<li><strong>ValueError:</strong>  The error is raised if string_mid_type is not one of\nthe following 'scaled', 'normalized'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>plotly.graph_objects.Figure: This chart contains the resulting Mutual\n    Information diagram.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">list_df_input</span>,</span><span class=\"param\">\t<span class=\"n\">string_reference_model</span>,</span><span class=\"param\">\t<span class=\"n\">string_mid_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;scaled&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">dict_mi_parameters</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;string_entropy_method&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;auto&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;int_mi_n_neighbors&#39;</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"s1\">&#39;discrete_models&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;auto&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;bool_discrete_reference_model&#39;</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"s1\">&#39;int_random_state&#39;</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">}</span>,</span><span class=\"param\">\t<span class=\"n\">bool_normalized_measures</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "polar_diagrams.polar_diagrams.chart_create_all_diagrams", "modulename": "polar_diagrams.polar_diagrams", "qualname": "chart_create_all_diagrams", "kind": "function", "doc": "<p>chart_create_all_diagrams creates both the Taylor and the Mutual\nInformation diagrams (side-by-side) according to the list_df_input argument\nwhere models are placed in columns and rows contain model predictions.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>list_df_input (list):</strong>  This list contains one or two dataframes which\nhave models in columns and model prediction in rows. If parsed as a\npd.DataFrame() object, it is considered as a first and only element\nof the list. Each one of these dataframes is used to calculate\nrelevant statistical information and information theory properties.\nIf the list contains two elements, both dataframes need to have the\nsame set of columns. If the second dataframe contains only one row,\nthen this dataframe is considered to contain a property that is\nencoded as using size of the marker of the resulting diagrams. If the\nsecond dataframe contains multiple rows, it is then considered to be\na second version of the first dataframe in the list. This is then\nencoded using solid borders around circle marks in the resulting\ndiagrams.</li>\n<li><strong>string_reference_model (str):</strong>  This string contains the name of the\nmodel present in one or both elements of the list_df_input argument\n(as a column) which can be considered as a reference point in the\nfinal diagram. This is often the ground truth.</li>\n<li><strong>string_corr_method (str, optional):</strong>  This string contains the name of\nthe method to be used when calculating the correlation. Defaults to\n'pearson'.</li>\n<li><strong>string_mid_type (str, optional):</strong>  This string contains the type of the\nMutual Information diagram. If it is 'scaled' then it will span both\nquadrants. If it is 'normalized', it will span only the first\nquadrant of the circle. Defaults to 'scaled'.</li>\n<li><strong>dict_mi_parameters (dict, optional):</strong>  This dictionary contains\nconfiguration parameters for the calculation of entropy and mutual\ninformation. Defaults to\ndict(int_mi_n_neighbors=3, string_entropy_method='auto',\n     bool_discrete_reference_model=False, discrete_fetures='auto',\n     int_random_state=_INT_RANDOM_SEED).</li>\n<li><strong>bool_normalized_measures (bool, optional):</strong>  This boolean parameter is\nused to determine if the passed chart should have normalized entropy\nand STD values or not. If it is False, then real entropy and STD\nvalues are used for the radial axis. If it is True, normalized values\nare used. Defaults to False.</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>TypeError:</strong>  The error is raised if bool_notmalized_measures is not one\nof bool type.</li>\n<li><strong>ValueError:</strong>  The error is raised if string_mid_type is not one of\nthe following 'scaled', 'normalized'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>plotly.graph_objects.Figure: This chart contains the both the Taylor\n    and the Mutual Information diagrams side-by-side.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">list_df_input</span>,</span><span class=\"param\">\t<span class=\"n\">string_reference_model</span>,</span><span class=\"param\">\t<span class=\"n\">string_mid_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;scaled&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">string_corr_method</span><span class=\"o\">=</span><span class=\"s1\">&#39;pearson&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">dict_mi_parameters</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;string_entropy_method&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;auto&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;int_mi_n_neighbors&#39;</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"s1\">&#39;discrete_models&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;auto&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;bool_discrete_reference_model&#39;</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"s1\">&#39;int_random_state&#39;</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">}</span>,</span><span class=\"param\">\t<span class=\"n\">bool_normalized_measures</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();